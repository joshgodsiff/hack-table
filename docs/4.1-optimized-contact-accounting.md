# 4.1 Optimized Contact Accounting

The basic desired property of k-buckets is to provide LRU checking and eviction of invalid contacts without dropping any valid contacts. As described in Section 2.2, if a k-bucket is full, it requires sending a PING RPC every time a message is received from an unknown node in the bucket's range. The PING checks to see if the least-recently used contact in the k-bucket is still valid. If it isn't, the new contact replaces the old one. Unfortunately, the algorithm as described would require a large number of network messages for these PINGs.

To reduce traffic, Kademlia delays probing contacts until it has useful messages to send them. When a Kademlia node receives an RPC from an unknown contact and the k-bucket for that contact is already full with k entries, the node places the new contact in a replacement cache of nodes eligible to replace stale k-bucket entries. The next time the node queries contacts in the k-bucket, any unresponsive ones can be evicted and replaced with entries in the replacement cache. The replacement cache is kept sorted by time last seen, with the most recently seen entry having the highest priority as a replacement candidate.

A related problem is that because Kademlia uses UDP, valid contacts will sometimes fail to respond when network packets are dropped. Since packet loss often indicates network congestion, Kademlia locks unresponsive contacts and avoids sending them any further RPCs for an exponentially increasing backoff interval. Because at most stages Kademlia's lookup only needs to hear from one of Î± nodes, the system typically does not retransmit dropped RPCs to the same node.

When a contact fails to respond to 5 RPCs in a row, it is considered stale. If a k-bucket is not full or its replacement cache is empty, Kademlia merely flags stale contacts rather than remove them. This ensures, among other things, that if a node's own network connection goes down temporarily, the node won't completely void all of its k-buckets.